#!/usr/bin/env python3.6
import sys
import asyncio
import telepot
import re
import os
import time
import random

#  Load external modules
from shemutils.logger import Logger
from telepot.aio.delegate import pave_event_space, per_chat_id, create_open

#  Load internal modules
from telemanager.database import *
from telemanager.io import *
from telemanager.talk import *
from telemanager.tasks import new_task_regex, delete_task_regex, list_task_regex, list_all_tasks, delete_a_task, create_new_task, present_tasks


#  Create the logger object
log = Logger("TeleManager")


create_cache_dir()

#  Check if token arg is filled
if len(sys.argv) < 2:
    log.critical("Not enough arguments to run this bot.")
    log.info("Usage: {0} <TOKEN>".format(sys.argv[0]))
    sys.exit(1)
else:
    TOKEN = sys.argv[1]


def search_pattern(txt):
    pattern = "(^procurar?|^buscar?|^search?|^pesquisar)\s+(?P<file>[\w\.]+)"
    m = re.match(pattern, txt)
    if not m:
        return None
    match = m.groupdict()
    return match


def search_file(match):
    """
    Function to look for files based on regex match
    """

    def look_for_file(kw):
        """
        Traverse the file directory
        """
        results = set()
        for root, dirc, files in os.walk(cache_dir):
            for file in files:
                if kw.lower() in file.lower():
                    path = ''.join(os.path.join(root, file))
                    results.add(path)
        return results

    keyword = match["file"]
    return look_for_file(keyword)


def search_messages(match):
    keyword = match["file"]
    db.controller.execute(t1.search("MESSAGE", keyword))
    results = db.controller.get()
    return results


def parse_date(d):
    #  Log for debugging purposes.
    #  log.debug("Date data: {0}".format(d))
    regex = "(?P<d>[\w]+)\s+(?P<m>[\w]+)\s+(?P<dn>[\d]+)\s+(?P<h>[\d]+:[\d]+:[\d]+)"
    m = re.match(regex, d)
    if not m:
        return None
    else:
        return m.groupdict()


class BotHandler(telepot.aio.helper.ChatHandler):
    def __init__(self, *args, **kwargs):
        super(BotHandler, self).__init__(*args, **kwargs)
        self._count = 0

    @staticmethod
    def _recvd_from(message):
        first_name = message["from"]["first_name"]
        try:
            last_name = message["from"]["last_name"]
        except KeyError:
            last_name = ""
        username = " ".join([first_name, last_name])
        return first_name, last_name, username

    async def _message_search(self, text):
        sp = search_pattern(text)
        if not sp:
            return -1

        log.debug("Trying to find data about '{0}'".format(sp["file"]))
        messages = search_messages(sp)
        if len(messages) > 0:
            await self._parse_message_results(messages)

        files = search_file(sp)
        if len(files) > 1:
            #  Generate a list to send to user(s)
            st = str()
            fl = ["%s\n" % os.path.basename(x) for x in files]
            for e in fl:
                st += e

            template = "Encontrei {0} arquivos com essa palavra:\n{1}".format(len(files), st)
            await self.sender.sendMessage(template)
        elif len(files) == 1:
            keyword = os.path.basename(list(files)[0])
            file_name = t2.search("FILE_NAME", keyword)
            db.controller.execute(file_name)
            result = db.controller.get()
            for item in result:
                fid, user, file_id, file_name = item[0], item[1], item[2], item[3]
                await self.sender.sendMessage("Enviando arquivo '_{0}_' ...".format(file_name), parse_mode="Markdown")
                await self.sender.sendDocument(file_id)
        return 0

    async def _tasks(self, username, chat_id, text):
        """
        Function handler for managing tasks
        """
        task_r = new_task_regex(text)
        task_l = list_task_regex(text)
        task_d = delete_task_regex(text)

        if not task_r and not task_l and not task_d:
            #log.debug("No task regex found.")
            return -1

        if task_r:  # Register a task
            #log.debug("Task create found.")
            task = task_r["task"]
            if not task:
                return -1

            if create_new_task(username, chat_id, task) != 0:
                log.error("Could not create task: {0}".format(task))
                return -1

            log.debug("Task created: {0}".format(task))
            await self.sender.sendMessage("Nova tarefa *registrada*!", parse_mode="Markdown")
            return 0

        if task_l:  # List tasks
            #log.debug("Task list found.")
            result = list_all_tasks(chat_id)
            if result == -1:
                await self.sender.sendMessage(random.choice(cant_find_tasks), parse_mode="Markdown")
                return 0
            await self.sender.sendMessage(present_tasks(result), parse_mode="Markdown")
            log.debug("Task list sent to {0}".format(username))
            return 0

        if task_d:
            #log.debug("Task delete found.")
            task_id = task_d["task_id"]
            if delete_a_task(task_id) != 0:
                log.error("Could not delete task.")
            await self.sender.sendMessage(random.choice(deleted_tasks), parse_mode="Markdown")
        return -1

    def _log_message(self, text, username):
        """
        Log the message received into the database.
        """
        insert_data = t1.insert_data([username, text, str(time.time())])
        db.controller.execute(insert_data)
        db.save()  # Store conversation data
        log.debug("Message save to database.\n")
        return 0


    async def on_chat_message(self, message):
        """
        Bot Message Handler
        """
        self._count += 1
        content_type, chat_type, chat_id = telepot.glance(message)
        #user_id = message["from"]["user_id"]
        first_name, last_name, username = self._recvd_from(message)
        auth = AuthenticationCheck(user_id).check()
        if auth == -1:
            log.debug("User #{0} - {1} is not authorized to use my functions.".format(user_id, username))
            return -1

        #  Code flow based on content_type
        #  Photos (.jpg, .png)
        if content_type == "photo":
            photo_id = message["photo"][0]["file_id"]
            insert_data = t2.insert_data([username, photo_id, photo_id])
            db.controller.execute(insert_data)
            db.save()

            if not os.path.exists(cache_dir + os.sep + photo_id):
                await self.bot.download_file(photo_id, cache_dir + os.sep + photo_id + ".jpg")
                await self.sender.sendMessage(random.choice(image_download).format(photo_id), parse_mode="Markdown")

        #  Text data
        elif content_type == "text":
            text = str(message["text"].lower()).replace("'",'"')

            #  Logging for debugging purposes.
            log.debug("Message FROM object: {0}".format(message["from"]))
            log.debug("Received message: {0}".format(text))


            #  Search algorithms
            await self._message_search(text)
            await self._tasks(username, chat_id, text)

            #  Log the messages
            self._log_message(username, text)

        # Document (PDF, .DOCX)
        elif content_type == "document":
            document_name = message["document"]["file_name"]
            document_id = message["document"]["file_id"]
            insert_data = t2.insert_data([username, document_id, document_name])
            db.controller.execute(insert_data)
            db.save()

            #  Avoiding too much verbose
            #await self.sender.sendMessage("Baixando arquivo {0} ...".format(document_name))

            if not os.path.exists(cache_dir + os.sep + document_name):
                await self.bot.download_file(document_id, cache_dir + os.sep + document_name)
                await self.sender.sendMessage(random.choice(file_download).format(document_name), parse_mode="Markdown")

        # Videos (.mp4, .mkv)
        elif content_type == "video":
            video_id = message["video"]["file_id"]
            video_name = message["video"]["file_name"]
            insert_data = t2.insert_data([username, video_id, video_name])
            db.controller.execute(insert_data)
            db.save()

            #  Avoiding too much verbose
            #await self.sender.sendMessage("Baixando video {0} ...".format(video_name))

            if not os.path.exists(cache_dir + os.sep + video_name):
                await self.bot.download_file(video_id, cache_dir + os.sep + video_name)
                await self.sender.sendMessage(random.choice(video_download).format(video_name), parse_mode="Markdown")

        else:
            # Send unknown type message
            log.debug("Tipo de entrada de dados \
                    desconhecida! \nContent-Type: {0}".format(content_type))

    async def _parse_message_results(self, results, n=5):
        """
        Parse a maximum of 5 posts about the topic
        """
        output = []
        if len(results) > n:
            for _ in range(n):
                output.append(results.pop())
        else:
            for _ in range(len(results)):
                output.append(results.pop())

        str_output = ""
        for element in output:
            mid, user, msg, timestamp = element[0], element[1], element[2], element[3]
            timestamp = time.ctime(float(timestamp))
            date = parse_date(timestamp)
            if not date:
                print("[+] Erro convertendo timestamp")
                return 1

            template = "No dia {0} de {1} as {2}, o usuario {3} disse:\n'{4}'".format(date["dn"], date["m"], date["h"], user, msg)
            await self.sender.sendMessage(template)
        return 0


bot = telepot.aio.DelegatorBot(TOKEN, [
    pave_event_space()(
        per_chat_id(), create_open, BotHandler, timeout=60),
    ])

loop = asyncio.get_event_loop()
loop.create_task(bot.message_loop())
log.info("TeleManager bot has started.")
loop.run_forever()
